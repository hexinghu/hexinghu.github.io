---
title: numpy学习教程
date: 2019-09-02 15:22:36
categories:
    - python
tags:
    - python
    - numpy
    - 数据处理
    - 机器学习
---

### NumPy--快速处理数据    
[numpy官网](http://www.numpy.org/)
 1 创建数组
 


首先需要创建数组对象才能对其进行运算和操作。可以通过给array()函数传递python的序列对象来创建数组，如果传递的是多级嵌套的序列对象，则创建的是
 多维数组
 例如：


```python
import numpy as np
a = np.array([1,2,3,4])
b = np.array((1,2,3,4))
c = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12]])
print(a)
print(b)
print(c)
```

    [1 2 3 4]
    [1 2 3 4]
    [[ 1  2  3  4]
     [ 5  6  7  8]
     [ 9 10 11 12]]
    

数组的形状可以通过shape属性获得，它是描述一个数组各轴长度的一个元组（tuple)：


```python
a.shape
```




    (4,)




```python
b.shape
```




    (4,)




```python
c.shape
```




    (3, 4)



使用数组的reshape()方法可以创建指定形状的新数组而原数组形状不变 ** 注意：此时创建的新数组和原来的数组共享数据存储空间改变任何一个数组的值，对方的值也会跟着改变 **


```python
d = a.reshape((2,2))
print(d)
```

    [[2 2]
     [3 4]]
    


```python
a[0]=2
print(a,d)
```

    [2 2 3 4] [[2 2]
     [3 4]]
    

2 元素类型


数组的元素类型可以通过dtype属性获得


```python
print(a.dtype)

```

    int32
    

完整的元素类型可以通过下面的方法得到：


```python
set(np.typeDict.values())
```




    {numpy.bool_,
     numpy.bytes_,
     numpy.complex128,
     numpy.complex128,
     numpy.complex64,
     numpy.datetime64,
     numpy.float16,
     numpy.float32,
     numpy.float64,
     numpy.float64,
     numpy.int16,
     numpy.int32,
     numpy.int32,
     numpy.int64,
     numpy.int8,
     numpy.object_,
     numpy.str_,
     numpy.timedelta64,
     numpy.uint16,
     numpy.uint32,
     numpy.uint32,
     numpy.uint64,
     numpy.uint8,
     numpy.void}



使用astype()方法可以改变数组元素的类型,这种改变会生成一个新的数组，原来的数组并不会改变


```python
t = a.astype(np.int64)
print(t.dtype,a.dtype)
```

    int64 int32
    

3 自动生成数组

NumPy提供了很多专门用来创建数组的方法，例如：
* arange()方法和range()方法类似，指定开始值和结束值以及步长(默认为1)


```python
np.arange(1,9,2)
```




    array([1, 3, 5, 7])



上面参数1表示开始值，参数9表示终止值，参数2表示步长

* linspace()方法和logspace()方法


```python
np.linspace(1,1.5,10,endpoint=True)#1表示起始值，1.5表示终止值，10表示元素个数，生成一个等差数组

```




    array([1.        , 1.05555556, 1.11111111, 1.16666667, 1.22222222,
           1.27777778, 1.33333333, 1.38888889, 1.44444444, 1.5       ])




```python
np.logspace(1,1.5,10,endpoint=True)#和linspace()类似，不过生成的是一个等比数组，默认是以10为基数，可以通过base参数指定基数
```




    array([10.        , 11.36463666, 12.91549665, 14.67799268, 16.68100537,
           18.95735652, 21.5443469 , 24.48436747, 27.82559402, 31.6227766 ])




```python
np.logspace(1,1.5,10,base=2,endpoint=True)
```




    array([2.        , 2.07851845, 2.16011948, 2.2449241 , 2.33305808,
           2.42465213, 2.5198421 , 2.61876915, 2.72158   , 2.82842712])



* zeros()、ones()、empty()可以创建指定形状的数组，其中empty()方法只分配数组使用的内存，不对数组初始化


```python
np.zeros((2,3),dtype=np.float32)
```




    array([[0., 0., 0.],
           [0., 0., 0.]], dtype=float32)




```python
np.ones((2,3))
```




    array([[1., 1., 1.],
           [1., 1., 1.]])




```python
np.empty((2,3))
```




    array([[1., 1., 1.],
           [1., 1., 1.]])



* zeros_like()、ones_like()、empty()和full_like()方法创建和参数数组形状和类型相同的数组，例如：


```python
np.zeros_like(d)
```




    array([[0, 0],
           [0, 0]])




```python
np.ones_like(d)
```




    array([[1, 1],
           [1, 1]])




```python
np.empty_like(a)
```




    array([         1,          0, 1969513842, 1600087395])




```python
np.full_like(b,fill_value=2)
```




    array([2, 2, 2, 2])



* fromstring()、frombuffer()、fromfunction()、fromfile()方法


```python
s = 'abcgfgij'
np.fromstring(s,np.int8)
```

    D:\Anaconda\lib\site-packages\ipykernel_launcher.py:2: DeprecationWarning: The binary mode of fromstring is deprecated, as it behaves surprisingly on unicode inputs. Use frombuffer instead
      
    




    array([ 97,  98,  99, 103, 102, 103, 105, 106], dtype=int8)




```python
def func(i,j):
    return (i+1)*(j+1)
np.fromfunction(func,(9,9))
```




    array([[ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.],
           [ 2.,  4.,  6.,  8., 10., 12., 14., 16., 18.],
           [ 3.,  6.,  9., 12., 15., 18., 21., 24., 27.],
           [ 4.,  8., 12., 16., 20., 24., 28., 32., 36.],
           [ 5., 10., 15., 20., 25., 30., 35., 40., 45.],
           [ 6., 12., 18., 24., 30., 36., 42., 48., 54.],
           [ 7., 14., 21., 28., 35., 42., 49., 56., 63.],
           [ 8., 16., 24., 32., 40., 48., 56., 64., 72.],
           [ 9., 18., 27., 36., 45., 54., 63., 72., 81.]])



4 存取元素

可以使用和列表相同的方式对数组进行存取，不同的是通过切片操作获得的数组是原始数组的一个视图，与原始数组共享同一块数据存储空间


```python
 g = np.arange(10)
```


```python
print(g)
```

    [0 1 2 3 4 5 6 7 8 9]
    


```python
g[3]
```




    3




```python
g[3:]
```




    array([3, 4, 5, 6, 7, 8, 9])




```python
g[3:5]
```




    array([3, 4])




```python
g[:-1]
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8])




```python
g[-5:-3]
```




    array([5, 6])




```python
g[:]
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])



除了切片下标存取元素外，NumPy还提供了整数列表、整数数组、布尔数组等几种高级下表存取法 *** 注意：不和原始数组共享数据空间 ***


```python
g[[1,2,4]]
```




    array([1, 2, 4])




```python
g[[4,3,8,1]]
```




    array([4, 3, 8, 1])



5 ufunc函数（通用函数）

ufunc函数都是用C语言写的，因此计算速度非常快，让我们来看个例子：


```python
%timeit
import numpy as np
x = np.linspace(0,2*np.pi,10)
np.sin(x)
```




    array([ 0.00000000e+00,  6.42787610e-01,  9.84807753e-01,  8.66025404e-01,
            3.42020143e-01, -3.42020143e-01, -8.66025404e-01, -9.84807753e-01,
           -6.42787610e-01, -2.44929360e-16])




```python
t = np.sin(x,out=x)
t
```




    array([ 0.00000000e+00,  6.42787610e-01,  9.84807753e-01,  8.66025404e-01,
            3.42020143e-01, -3.42020143e-01, -8.66025404e-01, -9.84807753e-01,
           -6.42787610e-01, -2.44929360e-16])




```python
t is x
```




    True



从上面可以看出，我们可以通过out参数来指定输出对象。

数组的运算符及对应的ufunc函数：

| 表达式| 对应的ufunc函数 |
| :-: | :-: |
| $ y=x1 + x2 $ | add(x1,x2,\[,y\] |
| $ y=x1 - x2 $ | subtract(x1,x2,\[,y\] |
| $ y=x1 * x2 $ | multiply(x1,x2,\[,y\] |
| $ y=x1 / x2 $ | divide(x1,x2,\[,y\] |
| $ y=x1 // x2 $ | floor_divide(x1,x2,\[,y\] |
| $ y=x1 ** x2 $ | power(x1,x2,\[,y\] |
| $ y=x1 \% x2 $ | mod(x1,x2,\[,y\] |
| $ y=-x $ | negative(x,\[,y\] |


 6 广播

当使用ufunc函数对两个数组进行计算时，ufunc函数会对这连个数组的对应元素进行计算，因此他要求连个数组的形状要一样。如果形状不同会对数组进行广播处理：
*  让所有输入数组都向其中维数最多的数组看起，shape属性中不足的部分通过在前面加1补齐；
*  输出数组的shape属性是输入数组的shape属性的各个轴上的最大值；
*  如果输入数组的某个轴的长度为1或与输出数组的对应轴的长度相同，这个数组能够用来计算，否则出错；
*  当输入数组的某个轴的长度为1时，沿着此轴运算是都用此轴上的第一组值


```python
a = np.arange(0,1,0.1).reshape((-1,1))
a
```




    array([[0. ],
           [0.1],
           [0.2],
           [0.3],
           [0.4],
           [0.5],
           [0.6],
           [0.7],
           [0.8],
           [0.9]])




```python
b = np.arange(0,5)
b
```




    array([0, 1, 2, 3, 4])




```python
c = a+b
c 
```




    array([[0. , 1. , 2. , 3. , 4. ],
           [0.1, 1.1, 2.1, 3.1, 4.1],
           [0.2, 1.2, 2.2, 3.2, 4.2],
           [0.3, 1.3, 2.3, 3.3, 4.3],
           [0.4, 1.4, 2.4, 3.4, 4.4],
           [0.5, 1.5, 2.5, 3.5, 4.5],
           [0.6, 1.6, 2.6, 3.6, 4.6],
           [0.7, 1.7, 2.7, 3.7, 4.7],
           [0.8, 1.8, 2.8, 3.8, 4.8],
           [0.9, 1.9, 2.9, 3.9, 4.9]])




```python
c.shape
```




    (10, 5)




```python
b.shape = (1,5)
b
```




    array([[0, 1, 2, 3, 4]])




```python
b.repeat(6,axis=0)
```




    array([[0, 1, 2, 3, 4],
           [0, 1, 2, 3, 4],
           [0, 1, 2, 3, 4],
           [0, 1, 2, 3, 4],
           [0, 1, 2, 3, 4],
           [0, 1, 2, 3, 4]])




```python
a.repeat(5,axis=1)
```




    array([[0. , 0. , 0. , 0. , 0. ],
           [0.1, 0.1, 0.1, 0.1, 0.1],
           [0.2, 0.2, 0.2, 0.2, 0.2],
           [0.3, 0.3, 0.3, 0.3, 0.3],
           [0.4, 0.4, 0.4, 0.4, 0.4],
           [0.5, 0.5, 0.5, 0.5, 0.5],
           [0.6, 0.6, 0.6, 0.6, 0.6],
           [0.7, 0.7, 0.7, 0.7, 0.7],
           [0.8, 0.8, 0.8, 0.8, 0.8],
           [0.9, 0.9, 0.9, 0.9, 0.9]])



当然这样比较浪费内存空间，因为repeat()会生成新的数组，对此NumPy提供了ogrid对象，用于广播运算的数组


```python
x,y = np.ogrid[:5,:5]
x,y
```




    (array([[0],
            [1],
            [2],
            [3],
            [4]]), array([[0, 1, 2, 3, 4]]))



NumPy还提供了mgrid对象，与ogrid类似，不过它返回的是广播过后的数组


```python
x,y = np.mgrid[1:10,2:5]
x,y
```




    (array([[1, 1, 1],
            [2, 2, 2],
            [3, 3, 3],
            [4, 4, 4],
            [5, 5, 5],
            [6, 6, 6],
            [7, 7, 7],
            [8, 8, 8],
            [9, 9, 9]]), array([[2, 3, 4],
            [2, 3, 4],
            [2, 3, 4],
            [2, 3, 4],
            [2, 3, 4],
            [2, 3, 4],
            [2, 3, 4],
            [2, 3, 4],
            [2, 3, 4]]))



NumPy还提供了meshgrid()方法可以对列表进行广播


```python
x = [i*3-1 for i in range(10)]
x 
```




    [-1, 2, 5, 8, 11, 14, 17, 20, 23, 26]




```python
np.meshgrid(x,x)
```




    [array([[-1,  2,  5,  8, 11, 14, 17, 20, 23, 26],
            [-1,  2,  5,  8, 11, 14, 17, 20, 23, 26],
            [-1,  2,  5,  8, 11, 14, 17, 20, 23, 26],
            [-1,  2,  5,  8, 11, 14, 17, 20, 23, 26],
            [-1,  2,  5,  8, 11, 14, 17, 20, 23, 26],
            [-1,  2,  5,  8, 11, 14, 17, 20, 23, 26],
            [-1,  2,  5,  8, 11, 14, 17, 20, 23, 26],
            [-1,  2,  5,  8, 11, 14, 17, 20, 23, 26],
            [-1,  2,  5,  8, 11, 14, 17, 20, 23, 26],
            [-1,  2,  5,  8, 11, 14, 17, 20, 23, 26]]),
     array([[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
            [ 2,  2,  2,  2,  2,  2,  2,  2,  2,  2],
            [ 5,  5,  5,  5,  5,  5,  5,  5,  5,  5],
            [ 8,  8,  8,  8,  8,  8,  8,  8,  8,  8],
            [11, 11, 11, 11, 11, 11, 11, 11, 11, 11],
            [14, 14, 14, 14, 14, 14, 14, 14, 14, 14],
            [17, 17, 17, 17, 17, 17, 17, 17, 17, 17],
            [20, 20, 20, 20, 20, 20, 20, 20, 20, 20],
            [23, 23, 23, 23, 23, 23, 23, 23, 23, 23],
            [26, 26, 26, 26, 26, 26, 26, 26, 26, 26]])]



ufunc对象的其他方法（reduce和accumulate


```python
r1 = np.add.reduce([1,2,3])
r1
```




    6




```python
r2 = np.subtract.reduce([2,5,6])
r2
```




    -9




```python
np.add.accumulate([[1,2,3],[4,5,6]])
```




    array([[1, 2, 3],
           [5, 7, 9]], dtype=int32)




```python
np.add.accumulate([1,2,3,4,5])
```




    array([ 1,  3,  6, 10, 15], dtype=int32)




```python
np.multiply.outer([1,2,3,4],[2,5,3,6,8])
```




    array([[ 2,  5,  3,  6,  8],
           [ 4, 10,  6, 12, 16],
           [ 6, 15,  9, 18, 24],
           [ 8, 20, 12, 24, 32]])



7 函数库

* 随机数

|函数名|功能|
|:-:|:-:|
|rand|0到1之间的随机数|
|randn|标准正态分布随机数|
|randint|指定范围的随机数|
|normal|正态分布|
|uniform|均匀分布|
|possion|泊松分布|
|permutation|随机排列|
|shuffle|随机打乱顺序|
|choice|随机取样|
|seed|设置随机种子|


```python
np.random.rand(4,3)
```




    array([[0.49527903, 0.60504845, 0.77199809],
           [0.29434029, 0.28529868, 0.91671446],
           [0.75932054, 0.57987357, 0.50724197],
           [0.32430096, 0.28049917, 0.06121927]])




```python
np.random.randint(2,10,(4,3))
```




    array([[8, 8, 8],
           [5, 7, 3],
           [7, 5, 9],
           [3, 8, 6]])




```python
np.random.randn(4,5)
```




    array([[ 0.05342908,  0.53592508, -0.40835572, -1.57338237, -1.09763109],
           [-0.14483236, -0.67100518,  0.24233258, -0.47532544,  0.72091345],
           [ 0.71137182,  0.10584141, -0.49632466, -0.78513602,  1.62519341],
           [-0.56309118, -0.76332315, -1.1503351 ,  0.10328419, -0.81588498]])




```python
np.random.normal(5,0.8,(10,))
```




    array([3.2087878 , 4.65799672, 4.89149176, 4.95444905, 4.76988224,
           4.91956819, 5.13050569, 4.7800823 , 4.55731749, 5.91751027])




```python
np.random.uniform(1,10,(4,5))
```




    array([[9.65744436, 5.70799519, 6.27461113, 9.19422402, 3.41034932],
           [7.51633998, 7.2932394 , 6.61791867, 7.22796638, 3.84816789],
           [1.55636584, 9.28135459, 1.97108739, 6.9599354 , 9.40407354],
           [8.99814775, 7.04190946, 7.86347481, 7.53375282, 8.29634385]])




```python
b = [1,2,3,4,5,6]
np.random.shuffle(b)
b
```




    [2, 1, 4, 5, 3, 6]




```python
np.random.choice([1,2,3,4],(4,7))
```




    array([[4, 2, 2, 4, 2, 1, 2],
           [3, 3, 3, 3, 4, 2, 1],
           [4, 4, 3, 4, 1, 2, 4],
           [4, 2, 3, 2, 2, 2, 3]])




```python
np.random.seed(42)#随机种子的目的是为了后面可以生成相同的随机数
np.random.rand()
```




    0.3745401188473625




```python

np.random.rand()
```




    0.9507143064099162



* 统计函数

|函数名|功能|
|-|-|
|sum|求和|
|mean|求期望|
|average|加权平均数|
|std|标准差|
|var|方差|
|product|连续积|


```python
np.random.seed(0)
a=np.random.randn(4,5)
a
```




    array([[ 1.76405235,  0.40015721,  0.97873798,  2.2408932 ,  1.86755799],
           [-0.97727788,  0.95008842, -0.15135721, -0.10321885,  0.4105985 ],
           [ 0.14404357,  1.45427351,  0.76103773,  0.12167502,  0.44386323],
           [ 0.33367433,  1.49407907, -0.20515826,  0.3130677 , -0.85409574]])




```python
np.sum(a,axis=1)
```




    array([7.25139873, 0.12883298, 2.92489305, 1.0815671 ])




```python
np.sum(a,axis=0)
```




    array([1.26449236, 4.29859821, 1.38326024, 2.57241707, 1.86792399])




```python
np.sum(a)
```




    11.386691858912695




```python
np.mean(a)
```




    0.5693345929456347




```python
np.average(a)
```




    0.5693345929456347




```python
np.mean(a,axis=1)
```




    array([1.45027975, 0.0257666 , 0.58497861, 0.21631342])




```python
np.var(a)
```




    0.7228107940950779




```python
np.std(a)
```




    0.8501828003994658




```python
np.product(a)
```




    -4.055013942478093e-06




```python
np.argsort(a,axis=1)
```




    array([[1, 2, 0, 4, 3],
           [0, 2, 3, 4, 1],
           [3, 0, 4, 2, 1],
           [4, 2, 3, 0, 1]], dtype=int64)



* 大小和排序

|函数名|功能|
|-|-|
|min|最小值|
|max|最大值|
|minimum|二元最小值|
|maximun|二元最大|
|ptp|最大值与最小值之差|
|argmax|最大值的下标|
|argmin|最小值的下标|
|sort|排序|
|argsort|计算数组排序的下标|
|lexsort|多列排序|
|partition|快速前k位|
|argpartition|前k位的下标|
|percentile|百分位数|
|median|中位数|
|searchsorted|二分查找|




```python
import numpy as np
a = np.random.randint(2,100,(100,))
np.min(a)
```




    2




```python
%timeit np.max(a)
```

    1.81 µs ± 11.4 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
    


```python
np.sort(np.random.rand(100))
np.argsort(np.random.rand(100))
```




    array([97, 11, 72, 30, 60, 52, 28, 75, 54, 81, 43, 56, 77, 98, 44, 23, 42,
           94, 13, 39, 29, 49, 25, 68, 61, 91, 70, 58, 79, 74, 62, 71, 17, 46,
           78, 33, 36, 50, 92, 66,  8, 35,  0, 89, 83, 55, 76, 51, 19, 45, 67,
           84,  9, 22, 40,  3, 53, 82, 87, 24, 31, 86, 32, 73, 99, 21, 63, 90,
           10,  1, 65,  4, 18, 16, 57, 34, 85, 27,  5, 88, 15,  2, 14, 93, 20,
           95, 12, 59, 69, 80, 26, 41, 96, 48,  6, 37, 47, 64, 38,  7],
          dtype=int64)




```python
np.max(b)
```




    2.5262962365792805




```python
np.argmax(b)
```




    31




```python
np.median(b)
```




    -0.07356846734112592




```python
np.partition(b,6)
```




    array([[ 0.15901081, -0.3639422 , -2.02490373, -0.42366511,  0.37729265,
             0.62517187,  0.68081547,  0.86333093],
           [ 0.50937255, -1.64159436, -0.34031755, -0.57832496,  0.82217681,
             0.88734196,  0.92923577,  1.00878852],
           [-0.59238077, -1.55505163, -0.7315833 , -1.64042746, -0.47391527,
             0.79322182,  0.8266779 ,  0.90491161],
           [-0.74896089, -0.91997512, -0.97826657,  0.35158925,  1.3356274 ,
             0.52294697,  1.39123874,  2.52629624],
           [-2.07913431, -0.4995525 , -0.16268623,  0.26603377,  0.33612334,
             0.70243856,  0.73923414,  0.9126099 ],
           [-1.31729954, -0.56196892, -1.37429019, -0.94657033, -0.56136363,
            -0.46016858, -0.1725623 , -0.10085584],
           [-0.80918634, -0.18565911, -0.38894521, -2.38412256, -0.68680343,
             0.47252269,  0.59453658,  1.92300579],
           [-1.83286504, -0.04923095, -0.5535404 , -0.72469076, -0.0284096 ,
             0.05427901,  0.28148002,  0.4846959 ],
           [-2.21331893, -1.14016618, -2.26742709, -0.73581546,  0.27924965,
             0.6203761 ,  0.75951615,  1.24385148],
           [-0.14782764, -0.09790598, -1.29453151,  0.0087432 ,  0.02143666,
             0.39676434,  0.68461404,  1.52543929]])




```python
b
```




    array([[ 0.68081547, -0.42366511, -2.02490373,  0.37729265,  0.62517187,
             0.86333093,  0.15901081, -0.3639422 ],
           [ 1.00878852,  0.92923577, -0.34031755, -1.64159436,  0.50937255,
            -0.57832496,  0.88734196,  0.82217681],
           [-0.47391527,  0.8266779 , -0.7315833 , -1.55505163,  0.90491161,
            -0.59238077, -1.64042746,  0.79322182],
           [-0.91997512, -0.74896089,  1.3356274 ,  0.35158925,  0.52294697,
             1.39123874, -0.97826657,  2.52629624],
           [-0.4995525 , -2.07913431,  0.9126099 , -0.16268623,  0.73923414,
             0.70243856,  0.26603377,  0.33612334],
           [-0.56196892, -0.94657033, -1.37429019, -0.46016858, -0.56136363,
            -1.31729954, -0.10085584, -0.1725623 ],
           [ 0.59453658,  1.92300579, -0.38894521, -0.18565911, -0.68680343,
            -0.80918634, -2.38412256,  0.47252269],
           [ 0.4846959 , -0.72469076, -0.5535404 , -0.0284096 , -1.83286504,
             0.28148002,  0.05427901, -0.04923095],
           [ 0.27924965,  0.75951615,  0.6203761 , -1.14016618, -2.21331893,
            -0.73581546, -2.26742709,  1.24385148],
           [ 0.0087432 ,  1.52543929, -1.29453151, -0.09790598,  0.68461404,
             0.02143666, -0.14782764,  0.39676434]])



